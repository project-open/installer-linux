
<html><head>
<title>ns_register - NaviServer Built-in Commands</title>
<link rel="stylesheet" href="../man.css" type="text/css">
</head>
<! -- Generated from file '/usr/local/src/naviserver/doc/html/naviserver/files/ns_register.html' by tcllib/doctools with format 'html'
   -->
<! -- CVS: $Id$ ns_register.n
   -->
<body><div class="doctools">
<div id="man-header">
  <a href="http://wiki.tcl.tk/2090"><img
     src="http://naviserver.sourceforge.net/ns-icon-16.png"> <strong>NaviServer</strong></a>
  - programmable web server
</div>
<br>
<hr> [
  <a href="../../toc.html">Main Table Of Contents</a>
| <a href="../toc.html">Table Of Contents</a>
| <a href="../../index.html">Keyword Index</a>
] <hr>
<h1 class="title">ns_register(n) 4.99.8 naviserver &quot;NaviServer Built-in Commands&quot;</h1>
<div id="name" class="section"><h2><a name="name">Name</a></h2>
<p>ns_register - Register Tcl/ADP handlers</p>
</div>
<div id="toc" class="section"><h2><a name="toc">Table Of Contents</a></h2>
<ul class="toc">
<li class="section"><a href="#toc">Table Of Contents</a></li>
<li class="section"><a href="#synopsis">Synopsis</a></li>
<li class="section"><a href="#section1">Description</a></li>
<li class="section"><a href="#section2">COMMANDS</a></li>
<li class="section"><a href="#section3">OPTIONS</a></li>
<li class="section"><a href="#section4">ARGUMENTS</a></li>
<li class="section"><a href="#section5">EXAMPLES</a></li>
<li class="section"><a href="#see-also">See Also</a></li>
<li class="section"><a href="#keywords">Keywords</a></li>
</ul>
</div>
<div id="synopsis" class="section"><h2><a name="synopsis">Synopsis</a></h2>
<div class="synopsis">
<ul class="syntax">
<li><a href="#1"><b class="cmd">ns_register_adp</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?<b class="option">-expires <i class="arg">t</i></b>?</span> <span class="opt">?<b class="option">-options <i class="arg">options</i></b>?</span> <span class="opt">?--?</span> <i class="arg">method</i> <i class="arg">URL</i> <span class="opt">?<i class="arg">file</i>?</span></a></li>
<li><a href="#2"><b class="cmd">ns_register_fastpath</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?--?</span> <i class="arg">method</i> <i class="arg">URL</i></a></li>
<li><a href="#3"><b class="cmd">ns_register_filter</b> <i class="arg">when</i> <i class="arg">method</i> <i class="arg">URL</i> <i class="arg">script</i> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#4"><b class="cmd">ns_register_proc</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?<i class="arg">--</i>?</span> <i class="arg">method</i> <i class="arg">URL</i> <i class="arg">myproc</i> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#5"><b class="cmd">ns_register_proxy</b> <i class="arg">method</i> <i class="arg">protocol</i> <i class="arg">script</i> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#6"><b class="cmd">ns_register_tcl</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?<b class="option">-cache cache</b>?</span> <span class="opt">?--?</span> <i class="arg">method</i> <i class="arg">URL</i> <span class="opt">?<i class="arg">file</i>?</span></a></li>
<li><a href="#7"><b class="cmd">ns_register_trace</b> <i class="arg">method</i> <i class="arg">URL</i> <i class="arg">script</i> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#8"><b class="cmd">ns_register_url2file</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?--?</span> <i class="arg">URL</i> <i class="arg">script</i> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#9"><b class="cmd">ns_register_fasturl2file</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?--?</span> <i class="arg">URL</i> <span class="opt">?<i class="arg">basepath</i>?</span></a></li>
<li><a href="#10"><b class="cmd">ns_unregister_op</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?<b class="option">-recurse</b>?</span> <span class="opt">?--?</span> <i class="arg">method</i> <i class="arg">URL</i></a></li>
<li><a href="#11"><b class="cmd">ns_unregister_url2file</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?<b class="option">-recurse</b>?</span> <span class="opt">?--?</span> <i class="arg">URL</i></a></li>
</ul>
</div>
</div>
<div id="section1" class="section"><h2><a name="section1">Description</a></h2>
<p>This document describes various command to bind Tcl code and/or
ADP-pages to URL patterns.</p>
</div>
<div id="section2" class="section"><h2><a name="section2">COMMANDS</a></h2>
<dl class="definitions">
<dt><a name="1"><b class="cmd">ns_register_adp</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?<b class="option">-expires <i class="arg">t</i></b>?</span> <span class="opt">?<b class="option">-options <i class="arg">options</i></b>?</span> <span class="opt">?--?</span> <i class="arg">method</i> <i class="arg">URL</i> <span class="opt">?<i class="arg">file</i>?</span></a></dt>
<dd><p>Requests to the server which match the <i class="arg">method</i> and <i class="arg">URL</i>
will trigger the <i class="term"><a href="../../index.html#key15">ADP</a></i> page request handler. If <i class="arg">file</i> is
given then it is the specific <i class="term"><a href="../../index.html#key15">ADP</a></i> page which should respond to all
matching requests. Otherwise, the <i class="term"><a href="../../index.html#key15">ADP</a></i> page will be located at request
time using <b class="cmd"><a href="ns_url2file.html">ns_url2file</a></b>.</p>
<p>This commands works similar as <b class="cmd">ns_register_tcl</b>, but registers an
ADP file instead of a Tcl script.</p>
<p>Use <b class="cmd">ns_unregister_op</b> to unregister an ADP request.</p></dd>
<dt><a name="2"><b class="cmd">ns_register_fastpath</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?--?</span> <i class="arg">method</i> <i class="arg">URL</i></a></dt>
<dd><p>This command register given <i class="arg">URL</i> to be processed by fast path subsystem, i.e.
all requestes that match will be served by corresponding .adp files if resolved. This
can be used when there is no global fast path handler installed.</p>
<p>The argument <i class="arg">method</i> is restricted to GET, POST or HEAD</p></dd>
<dt><a name="3"><b class="cmd">ns_register_filter</b> <i class="arg">when</i> <i class="arg">method</i> <i class="arg">URL</i> <i class="arg">script</i> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd><p><i class="term">ns_register_filter</i> registers a Tcl filter script for the specified method/URL combination
on a virtual server. The script can be called at one or more of three given times:
pre-authorization, post-authorization before page data has been returned to the user,
and after the connection has been processed and closed.</p>
<p>This function will be called at the specified stage of a connection, if the method/URL
combination for the filter matches the method/URL combination for the connection using glob style matching.</p>
<p>The URL can contain standard string-matching characters. For example, these are valid URLs:</p>
<pre class="example">
   /employees/*.tcl
   /accounts/*/out
</pre>
<p>Valid values for the when argument are: preauth, postauth, and trace.</p>
<p>Using pre-authorization, the procedure will be called (assuming that the method/URL
combination matches) just before authorization. If the procedure returns with a code of:</p>
<ul class="itemized">
<li><p>TCL_OK (using: return &quot;filter_ok&quot;): The server will continue to the next pre-authorization
         filter for this connection, or, if there are no more pre-authorization filters, it will
          continue on with authorization.</p></li>
<li><p>TCL_BREAK (using: return &quot;filter_break&quot;): The server will not process any more pre-authorization
         filters for this connection, and it will continue on with authorization.</p></li>
<li><p>TCL_RETURN (using: return &quot;filter_return&quot;): The server will close the connection and will
         not run any more pre-authorization filters. It will not authorize the request, and it will
         not run the function registered for this METHOD/URL. It WILL run any trace functions
         registered for this METHOD/URL, usually including logging. It is assumed that the filter
         has sent a proper response (e.g., using <b class="cmd"><a href="ns_return.html">ns_return</a></b>) to the client before returning TCL_RETURN.</p></li>
</ul>
<p>Using post-authorization, the procedure will be called (assuming that the method/URL combination matches)
just after successful authorization. If the procedure returns:</p>
<ul class="itemized">
<li><p>TCL_OK (using: return &quot;filter_ok&quot;): The server will continue to the next post-authorization
         filter for this connection, or, if there are no more post-authorization filters, it will run
         the function registered to handle this request.</p></li>
<li><p>TCL_BREAK (using: return &quot;filter_break&quot;): The server will not process any more post-authorization
         filters for this connection, and it will run the function registered to handle this request.</p></li>
<li><p>TCL_RETURN (using: return &quot;filter_return&quot;): The server will close the connection and will
         not run any more post-authorization filters and it will not run the function registered for
         this METHOD/URL. It WILL run any trace functions registered for this METHOD/URL, usually
         including logging. It is assumed that the filter has returned a proper response (e.g.,
          using <b class="cmd"><a href="ns_return.html">ns_return</a></b>) to the client before returning TCL_RETURN.</p></li>
</ul>
<p>Using trace, the procedure will be called (assuming that the method/URL combination match) after
the connection has been totally processed and closed. If the procedure returns:</p>
<ul class="itemized">
<li><p>TCL_OK (using: return &quot;filter_ok&quot;): The server will continue to the next trace filter.</p></li>
<li><p>TCL_BREAK, TCL_RETURN (using: return &quot;filter_break&quot; or return &quot;filter_return&quot;): The rest
         of the trace filters are ignored.</p></li>
</ul>
<p><i class="term">ns_register_filter</i> and <i class="term">ns_register_proc</i> are similar, but significantly different.
With <i class="term">ns_register_proc</i>, the specified URL is used to match that URL and any URL below
it in the hierarchy. Wildcards such as &quot;*&quot; are meaningful only for the final part of
the URL, such as /scripts/*.tcl. With <i class="term">ns_register_filter</i>, the URL is used to
match URLs as a string with standard string-matching characters. <i class="term">ns_register_proc</i>
results in a single match, whereas multiple <i class="term">ns_register_filters</i> can be matched and
will be called.</p>
<p>Be aware that executing the same <i class="term">ns_register_filter</i> statement more than once (as
you might do when re-initializing Tcl) will add the filter more than once! You
may want to have a shared variable set so that you don't do this.</p>
<p>This example shows how to expire all HTML files after an hour:</p>
<pre class="example">
    if {![nsv_exists filters installed]} {
      nsv_set filters installed 1
      ns_register_filter postauth GET /*.html ExpireSoon 3600
    }
    
    proc ExpireSoon {seconds why} {
      ns_set update [ns_conn outputheaders] Expires [ns_httptime [expr {$seconds + [ns_time]}]]
    }
    
</pre>
<p>The command <b class="cmd"><a href="ns_info.html">ns_info</a></b> <i class="arg">requestprocs</i> can be used to list the
currently registerd procs.</p></dd>
<dt><a name="4"><b class="cmd">ns_register_proc</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?<i class="arg">--</i>?</span> <i class="arg">method</i> <i class="arg">URL</i> <i class="arg">myproc</i> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd><p><i class="term">ns_register_proc</i> registers the procname to handle the specified method/URL combination.
When the server gets a matching request, it calls procname with the connection id and
any arguments specified here.</p>
<p>If <i class="arg">-noinherit</i> is specified, the requested URL must match the specified URL exactly.
For example, if the URL specified with <i class="term">ns_register_proc</i> is /foo/bar, procname will
not be called unless the requested URL is exactly /foo/bar.</p>
<p>If -noinherit is not specified, the requested URL can match the specified URL or any
URL below it.  For example, if the URL specified with <i class="term">ns_register_proc</i> is /foo/bar,
procname will be called for /foo/bar, /foo/bar/hmm, and any other URL below /foo/bar,
provided there is not already another procedure registered for that exact URL or for
an URL with a closer match.
Note that you must use a glob-style matching character if you want inheritance
for file names.  For example, if you want /foo/bar to match /foo/bar.html, you must use:</p>
<pre class="example">
   ns_register_proc /foo/bar*
</pre>
<p>You can register two procedures for any given method/URL combination by calling <i class="term">ns_register_proc</i> once with the -noinherit flag set and once without it.  Only one of the procedures will be called for any given request, depending on whether the URL was an exact match or not.  For example:</p>
<pre class="example">
   ns_register_proc -noinherit GET /foo/bar Aproc
   ns_register_proc GET /foo/bar Bproc
   ns_register_proc GET /foo/bar/hmm Cproc
</pre>
<p>Aproc will be called when the requested URL is exactly /foo/bar.  Bproc will be called when
 the requested URL is below /foo/bar, provided there is not already another procedure registered
 to be called for that exact URL or for an URL with a closer match.  Cproc (not Bproc) will be
 called when the requested URL is equal to or below /foo/bar/hmm.  Syntax for the registered
 procedure The conn (connection) argument is optional for procedures registered by <i class="term">ns_register_proc</i>
 if the procedure has 0 or 1 arguments
 (not including conn).  The following examples show the variations that can be used in this case:</p>
<pre class="example">
   ns_register_proc GET /noargs noargs
   ns_register_proc GET /context context fnord
   ns_register_proc GET /conncontext conncontext greeblev
   
   proc noargs { } {
       ns_returnnotice 200 &quot;noargs&quot;
   };# noargs
   
   proc context { context } {
       ns_returnnotice 200 &quot;context is $context&quot;
   };# context
   
   proc conncontext { conn context } {
       ns_returnnotice 200 &quot;conncontext is $context&quot;
   };# conncontext
</pre>
<p>The conn (connection) argument is required for procedures registered by <i class="term">ns_register_proc</i> if the
procedure has 2 or more arguments (not including conn).  The conn argument will be filled
automatically with the connection information.  The first argument following conn will always
take the value supplied by <i class="term">ns_register_proc</i>, if there is one, or an empty value.  All other
arguments must supply a default value.  The following examples show the variations that can
be used in this case:</p>
<pre class="example">
   ns_register_proc GET /twoargs twoargs fnord
   ns_register_proc GET /threeargs threeargs fnord fjord
   
   proc twoargs { conn context { greeble bork } } {
       # Do stuff...
   }
   
   proc threeargs { conn context {greeble bork } { hoover quark } {
       # Do stuff...
   }
</pre>
<p>When a GET of /twoargs is requested, the conn argument will be filled automatically,
the context argument will be assigned &quot;fnord&quot; and the greeble argument will be assigned
the default value &quot;bork&quot;.
When a GET of /threeargs is requested, the conn argument will be filled automatically,
the context argument will be assigned &quot;fnord&quot; and the greeble argument will be assigned &quot;fjord&quot;,
and the hoover argument will be assigned the default value &quot;quark&quot;.</p></dd>
<dt><a name="5"><b class="cmd">ns_register_proxy</b> <i class="arg">method</i> <i class="arg">protocol</i> <i class="arg">script</i> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd><p><i class="term">ns_register_proxy</i> registers a Tcl script as a handler for the specified method/protocol
combination.</p>
<p>Example of HTTP proxy server:</p>
<pre class="example">
   ns_register_proxy GET http http_proxy_handler
   
   proc http_proxy_handler { args } {
       set port [ns_conn port]
       if {$port == 0} {
           set port 80
       }
       set url http://[ns_conn host]:$port[ns_conn url]?[ns_conn query]
       ns_return 200 text/html [ns_httpget $url]]
   }
   
</pre>
</dd>
<dt><a name="6"><b class="cmd">ns_register_tcl</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?<b class="option">-cache cache</b>?</span> <span class="opt">?--?</span> <i class="arg">method</i> <i class="arg">URL</i> <span class="opt">?<i class="arg">file</i>?</span></a></dt>
<dd><p>Register Tcl file to be called when request matches method/URL
combination. This is to enable extention-less URLs or for mapping
actual files into virtual URLs. The command <b class="cmd">ns_register_tcl</b>
works similar as <b class="cmd">ns_register_adp</b> except the file to evaluate
should be a Tcl file which might use <b class="cmd"><a href="ns_return.html">ns_return</a></b>, <b class="cmd"><a href="ns_write.html">ns_write</a></b>
etc. to respond to the request.</p>
<p>If this argument <i class="arg">file</i> is omitted, the command  will register standard C-based
callback which will resolve URLs into absolute Tcl file and execute it.</p>
<p>Use <b class="cmd">ns_unregister_op</b> to unregister a Tcl request handler.</p></dd>
<dt><a name="7"><b class="cmd">ns_register_trace</b> <i class="arg">method</i> <i class="arg">URL</i> <i class="arg">script</i> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd><p><i class="term">ns_register_trace</i> registers a Tcl script as a trace for the specified method/URL
combination. After the server handles the request for the specified method on an
URL that matches the URL, it calls the trace script with the connection id
and any arguments (args) specified.</p>
<p>The URL can contain standard string-matching characters. For example, these are valid URLs:</p>
<pre class="example">
   /employees/*.tcl
   /accounts/*/out
</pre>
<p><i class="term">ns_register_trace</i> is similar to <i class="term">ns_register_proc</i> except that the
pattern-matching for the URL is performed differently. With <i class="term">ns_register_proc</i>,
the specified URL is used to match that URL and any URL below it in the hierarchy.
Wildcards such as &quot;*&quot; are meaningful only for the final part of the URL, such as
/scripts/*.tcl. With <i class="term">ns_register_trace</i>, the URL is used to match URLs as
a string with standard string-matching characters.</p>
<p><i class="term">ns_register_proc</i> results in a single match, whereas multiple <i class="term">ns_register_trace</i>'s
can be matched and will be called.</p></dd>
<dt><a name="8"><b class="cmd">ns_register_url2file</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?--?</span> <i class="arg">URL</i> <i class="arg">script</i> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd></dd>
<dt><a name="9"><b class="cmd">ns_register_fasturl2file</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?--?</span> <i class="arg">URL</i> <span class="opt">?<i class="arg">basepath</i>?</span></a></dt>
<dd><p>These commands are used to perform runtime resolving of the requested
urls into corresponding files that will be served to the client. They
use <b class="cmd"><a href="ns_url2file.html">ns_url2file</a></b> interface which resolves file for current
url. <b class="cmd">ns_register_fasturl2file</b> register the default fast url2file
proc for the given <i class="arg">URL</i>. The Tcl <i class="arg">script</i> 
provided to <b class="cmd">ns_register_url2file</b> 
is used to return full path to the requested URL.</p></dd>
<dt><a name="10"><b class="cmd">ns_unregister_op</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?<b class="option">-recurse</b>?</span> <span class="opt">?--?</span> <i class="arg">method</i> <i class="arg">URL</i></a></dt>
<dd><p>Unregister a Tcl or ADP request handler for the speci-
fied method/URL combination.
This command unregisters any Tcl or C functions previously registered 
for this method/URL combination and with the same inheritance
setting.  That is, if the <i class="arg">-noinherit</i> flag is specified with 
<i class="term">ns_unregister_op</i>, the function previously registered with the
<i class="arg">-noinherit</i> flag using <i class="term">ns_register_proc</i> (or the NS_OP_NOINHERIT
flag in ns_RegisterRequest) will be unregistered.  If <i class="arg">-noinherit</i>
is omitted, the function previously registered without the 
<i class="arg">-noinherit</i> flag (or the NS_OP_NOINHERIT flag) will be unregistered.</p></dd>
<dt><a name="11"><b class="cmd">ns_unregister_url2file</b> <span class="opt">?<b class="option">-noinherit</b>?</span> <span class="opt">?<b class="option">-recurse</b>?</span> <span class="opt">?--?</span> <i class="arg">URL</i></a></dt>
<dd><p>The command is the inverse command to  <b class="cmd">ns_register_url2file</b>.</p></dd>
</dl>
</div>
<div id="section3" class="section"><h2><a name="section3">OPTIONS</a></h2>
<dl class="options">
<dt><b class="option">-cache</b> <i class="arg">t</i></dt>
<dd><p>Specifies for how long to keep result in the cache, in seconds or absolute time.</p></dd>
<dt><b class="option">-expires</b> <i class="arg">t</i></dt>
<dd><p>Specifies that the result of evaluating the <i class="term"><a href="../../index.html#key15">ADP</a></i> page should be cached
for <i class="arg">t</i> seconds, or until <i class="arg">t</i> time in the future (expressed as
seconds after the <i class="term">epoch</i>) if <i class="arg">t</i> is large.</p></dd>
<dt><b class="option">-noinherit</b></dt>
<dd><p>Specifies that the directory portion of the request URL should match
exactly and not also apply to a URL lower in the hierarchy. This is
the default.</p>
<p>Different <i class="term"><a href="../../index.html#key15">ADP</a></i> page handlers can be registered for the
same <i class="arg">method</i> and <i class="arg">URL</i> if one uses the <span class="opt">?-noinherit?</span>
option and the other does not.</p>
<pre class="example">
   <b class="cmd">ns_register_adp</b>            GET /a x.adp
   <b class="cmd">ns_register_adp</b> -noinherit GET /b y.adp
</pre>
<p>In the previous example, a.adp will run for the requests /a, /a/b,
/a/b/c and so on. But b.adp will only run when the requested URL is
exactly /b. The request /b/c will result in a 404 Page Not Found error.</p>
<pre class="example">
   <b class="cmd">ns_register_adp</b>            GET /a x.adp
   <b class="cmd">ns_register_adp</b> -noinherit GET /a y.adp
</pre>
<p>In this example, a request for the exact URL /a will run the y.adp page, while
/a/b and /a/b/c will will run the x.adp page.  The y.adp page is more specific
than the x.adp page, and hides it for the /a request, which matched it exactly.</p></dd>
<dt><b class="option">-options</b> <i class="arg">options</i></dt>
<dd><p>A list of one or more <i class="term"><a href="../../index.html#key15">ADP</a></i> options that should be added to the default
set which are in effect while the <i class="term"><a href="../../index.html#key15">ADP</a></i> page runs. Options can only be
enabled, not disabled. Valid options are those that <b class="cmd"><a href="ns_adp_ctl.html">ns_adp_ctl</a></b>
accepts, which can be used by <i class="term"><a href="../../index.html#key15">ADP</a></i> code to fine tune the options.</p></dd>
<dt><b class="option">-recurse</b></dt>
<dd><p>if specified, the delete operation will be recursive.</p></dd>
</dl>
</div>
<div id="section4" class="section"><h2><a name="section4">ARGUMENTS</a></h2>
<dl class="arguments">
<dt>string <i class="arg">method</i></dt>
<dd><p>The HTTP <i class="arg">method</i>, such as <i class="term">HEAD</i>, <i class="term">GET</i> or <i class="term">POST</i>,
which will be compared using exact string equality to the HTTP request.</p>
<pre class="example">
   foreach method {HEAD GET POST} {
       <b class="cmd">ns_register_adp</b> $method /foo/bar &quot;<b class="file">hmm.adp</b>&quot;
   }
</pre>
</dd>
<dt>string <i class="arg">URL</i></dt>
<dd><p>The <i class="arg">URL</i> patterm to match against the URL in each HTTP request. The last
component of the URL may contain the globbing characters <i class="term">*</i> and <i class="term">?</i>.</p>
<pre class="example">
   <b class="cmd">ns_register_adp</b> GET /dynamic/*.htm?
</pre>
<p>In this example, a URL where the last component matches the pattern *.htm?,
such as /dynamic/foo.htm or /dynamic/a/b/c/bar.html, will be run by the
ADP engine.</p>
<p>Only the last component of the URL may be a pattern. If this is too restrictive,
try using <b class="cmd">ns_register_filter</b>.</p></dd>
<dt>string <i class="arg"><span class="opt">?file?</span></i></dt>
<dd><p>The optional  argument <i class="arg">file</i> is either an absolute path to a file in the file system,
or a path relative to the page root directory of the virtual server.</p>
<pre class="example">
   <b class="cmd">ns_register_adp</b> GET /a &quot;<b class="file">a.adp</b>&quot;    ; # relative to page root
   <b class="cmd">ns_register_adp</b> GET /b &quot;<b class="file">b/b.adp</b>&quot;  ; # relative to page root
   <b class="cmd">ns_register_adp</b> GET /c &quot;<b class="file">/c.adp</b>&quot;   ; # absolute in file-system root
</pre>
<p>The first and second lines specify a file relative to the page
root directory. The full path is constructed each time the <i class="term"><a href="../../index.html#key15">ADP</a></i> page is
requested using <b class="cmd"><a href="ns_pagepath.html">ns_pagepath</a></b>, so <b class="cmd">ns_serverroot</b> and
<b class="cmd">ns_register_url2file</b> callbacks will be taken into account.</p>
<p>In the third example, a specific <i class="term"><a href="../../index.html#key15">ADP</a></i> file in the server's file system
is registered for a simillarly named URL (and all URLs bellow
it). There are no calls to <b class="cmd"><a href="ns_pagepath.html">ns_pagepath</a></b> or <b class="cmd"><a href="ns_url2file.html">ns_url2file</a></b>
during the request.</p></dd>
</dl>
</div>
<div id="section5" class="section"><h2><a name="section5">EXAMPLES</a></h2>
<p>In the following example, all files with the .adp extension in and below the
/big URL should be served by the <i class="term"><a href="../../index.html#key15">ADP</a></i> handler, with the options
<i class="term">stricterror</i> and <i class="term">stream</i> enabled:</p>
<pre class="example">
   foreach method {GET HEAD POST} {
       <b class="cmd">ns_register_adp</b> -options {stream stricterror} -- $method /big/*.adp
   }
</pre>
</div>
<div id="see-also" class="section"><h2><a name="see-also">See Also</a></h2>
<p><a href="ns_adp.html">ns_adp</a>, <a href="ns_conn.html">ns_conn</a>, <a href="ns_info.html">ns_info</a></p>
</div>
<div id="keywords" class="section"><h2><a name="keywords">Keywords</a></h2>
<p><a href="../../index.html#key15">ADP</a>, <a href="../../index.html#key22">callback</a>, <a href="../../index.html#key72">fastpath</a>, <a href="../../index.html#key95">filter</a>, <a href="../../index.html#key94">request</a></p>
</div>
<div id="man-footer">
  
</div>
</div></body></html>
